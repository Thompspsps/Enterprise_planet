#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PlanetType {
    A, B, C, D
}
pub struct EnergyCell {
    charge: bool,
}
pub struct Rocket;

#[derive(Debug, Clone, Copy)]
pub enum BasicRscType {
    Oxygen,
    Hydrogen,
    Carbon,
    Silicon,
}

#[derive(Debug, Clone, Copy)]
pub enum ComplexRscType {
    Water,
    Diamond,
    Life,
    Robot,
    Dolphin,
    AIPartner,
}

pub struct Planetself {
    pub id: u32,
    pub energy_cells: Vec<EnergyCell>,
    pub rocket: Option<Rocket>,
}

#[derive(Debug)]
pub struct EnterprisePlanet {
    ai: AI,
    name: &'static str,
    generation_rule: BasicRscType,
    combination_rule: Vec<ComplexRscType>,
}

pub struct Planet<T: PlanetAI> {
    state: Planetself,
    planet_type: PlanetType,
    pub ai: T,
    from_orchestrator: mpsc::Receiver<OrchestratorToPlanet>,
    to_orchestrator: mpsc::Sender<PlanetToOrchestrator>,
    pub from_explorer: mpsc::Receiver<ExplorerToPlanet>,
    pub to_explorer: mpsc::Sender<PlanetToExplorer>,
}

pub trait Planetselfinfo {
    fn get_name(&self) -> &'static str;
    fn get_planet_type(&self) -> PlanetType;
    fn get_generation_rule(&self) -> Vec<BasicRscType>;
    fn get_combination_rule(&self) -> Vec<ComplexRscType>;
}

pub trait PlanetAI {
    fn handle_orchestrator_msg(
        &mut self,
        state: &mut Planetself,
        msg: OrchestratorToPlanet
    ) -> Option<PlanetToOrchestrator>;
    fn handle_explorer_msg(
        &mut self,
        state: &mut Planetself,
        msg: ExplorerToPlanet
    ) -> Option<PlanetToExplorer>;
    fn handle_asteroid(
        &mut self,
        state: &mut Planetself,
    ) -> Option<Rocket>;
    fn start(&mut self, state: &Planetself);
    fn stop(&mut self);
}

impl EnergyCell {
    pub fn new() -> Self {
        Self { charge: false }
    }
    pub fn is_charged(&self) -> bool {
        self.charge
    }
    pub fn charge(&mut self) {
        self.charge = true;
    }
    pub fn discharge(&mut self) -> Result<(), String> {
        if self.charge {
            self.charge = false;
            Ok(())
        } else {
            Err("the cell is not charged".to_string())
        }
    }
}

impl Rocket{
    fn build_rocket(&mut self) -> Result<(), String> {
        if self.rocket.is_some() {
            return Err("you have the rocket".to_string());
        }
        for cell in &mut self.energy_cells {
            if cell.is_charged() {
                match Rocket::new(cell) {
                    Ok(rocket) => {
                        self.rocket = Some(rocket);
                        return Ok(());
                    }
                    Err(e) => return Err(e),
                }
            }
        }
        Err("you need energy cells".to_string())
    }
}

impl Planetself {
    pub fn new(id: u32) -> Self {
        Self {
            id,
            energy_cells: vec![EnergyCell::new()], 
            rocket: None,
        }
    }
    pub fn id(&self) -> u32 {
        self.id
    }

    pub fn charge_by_sunray(&mut self) {
        for cell in &mut self.energy_cells {
            if !cell.is_charged() {
                cell.charge();
                break;
            }
        }
    }
    pub fn number_of_cells(&self, number: usize) -> bool {
        self.energy_cells.iter().filter(|c| c.is_charged()).count() >= number
    }

    pub fn build_rocket(&mut self) -> Result<(), String> {
        if self.rocket.is_some() {
            return Err("you have had the rocket".to_string());
        }
        else{
            for cell in &mut self.energy_cells {
                if cell.is_charged() {
                    match Rocket::new(cell) {
                        Ok(rocket) => {
                            self.rocket = Some(rocket);
                            return Ok(());
                        }
                        Err(e) => return Err(e),
                    }
                }
            }
        }
        Err("you do not have energy cell".to_string())
    }

    pub fn use_rocket(&mut self) -> Option<Rocket> {
        self.rocket.take()
    }
}

pub enum OrchestratorToPlanet {
    Sunray,
    Asteroid,
    StartPlanetAI,
    StopPlanetAI,
}

pub enum PlanetToOrchestrator {
    SunrayAck { planet_id: u32, timestamp: SystemTime },
    AsteroidAck { planet_id: u32, rocket: Option<Rocket> },
}

pub enum ExplorerToPlanet {
    SupportedResourceRequest { explorer_id: u32 },
    AvailableEnergyCellRequest { explorer_id: u32 },
}

pub enum PlanetToExplorer {
    SupportedResourceResponse { resource_list: Option<Vec<BasicRscType>> },
    AvailableEnergyCellResponse { available_cells: u32 },
}

impl EnterprisePlanet {
    pub fn new(
        name: &'static str,
        generation_rule: BasicRscType,
        combination_rule: Vec<ComplexRscType>
    ) -> Self {
        let rule = if combination_rule.len() > 6 {
            combination_rule.into_iter().take(6).collect()
        } else {
            combination_rule
        };

        Self {
            ai: AI::new(),
            name,
            generation_rule,
            combination_rule: rule,
        }
    }
    pub fn get_combination_rule(&self) -> Vec<&'static str> {
        self.combination_rule.iter().map(|rule| {
            match rule {
                ComplexRscType::Water => "Hydrogen + Oxygen = Water",
                ComplexRscType::Diamond => "Carbon + Carbon = Diamond",
                ComplexRscType::Life => "Water + Carbon = Life",              ComplexRscType::Robot => "Silicon + Life = Robot",               ComplexRscType::Dolphin => "Water + Life =Dolphin",  

ComplexRscType::AIPartner => "Robot + Diamond = AIPartner",
            }
        }).collect()
    }
    pub fn combination_rule(&self) -> &[ComplexRscType] {
        &self.combination_rule
    }
}
impl Planetselfinfo for EnterprisePlanet {
    fn get_name(&self) -> &'static str {
        self.name
    }

    fn get_planet_type(&self) -> PlanetType {
        PlanetType::C
    }

    fn get_generation_rule(&self) -> Vec<BasicRscType> {
        vec![self.generation_rule]
    }

    fn get_combination_rule(&self) -> Vec<ComplexRscType> {
        self.combination_rule.clone()
    }
}







